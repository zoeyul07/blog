---
emoji: ''
title: 'Blockchain: basic'
date: '2022-02-21 22:00:00'
author: seoyul
tags: blockchain
categories: BlockChain
---

다음 글은 Nomad Coder의 [암호화폐 101 with Nico](https://www.youtube.com/watch?v=ElGBP90XZWE&list=PL7jH19IHhOLOJfXeVqjtiawzNQLxOgTdq&index=3) 시리즈를 정리한 글 입니다.

## blockchain
블록체인은 블록들이 모여있는 체인으로 데이터베이스를 예로 들을 수 있다. 이 데이터베이스는 추가만 가능하고 삭제는 불가능하며 편집도 불가능하다.
블록체인은 탉중화화가 가능하며 특정 개인이 DB를 관리할 수 없고 모두가 DB의 복제본을 갖고 있는 분산된 DB로서 크립토를 감시하거나 통제하기 어렵게 만든다.(많은 사람들이 노드를 돌리고 있고 모두가 정확하게 동일한 DB 복제본을 갖고 있기 때문에 모두가 컴퓨터를 몽땅 꺼야 비트코인이 죽을 수 있지만 동시에 그런일이 일어날 일은 없기 때문에 불가능하다. 덕분에 크립토 커런시들이 정부의 감시나 통제에 대응할 수 있다.)

블록은 정보를 DB에 추가하는 방법이다. 데이터를 그냥 추가하는 것이 아니라 블록이라는 것으로 추가하며 비트코인의 경우 10분마다 블록이 생성된다.
블록에는 중요한 정보들이 많은데, 블록의 해시 이전 블록의 해시 그리고 데이터를 꼽을 수 있다.
비트코인의 경우 데이터는 트랜잭션, 즉 거래내역을 의미한다.(누가 얼마나 갖고있고 누가 누구에게 얼마나 보냈고.. 등등의 내용들이 비트고인 데이터 부분에 해당된다.)

해시는 수학 함수인데 한개의 인풋을 받으면 아웃풋을 준다. 이 함수는 일방향 함수이며 결정론적(deterministic)이다. 
결정론적이라는 단어의 의미는 input으로 "안녕"을 집어넣는다면 아웃풋은 항상 같은것으로 정해져있다는 의미이다. 만약 input에서 "안녕!" 처럼 조금이라도 바뀔 경우 output은 엄청나게 바뀌게 된다.
일방향 함수는 input을 넣으면 output을 구할 수 있지만 output을 갖고 input을 구할 수 없다는 의미이다.

블록체인에 블록을 추가하기 위해서는 비트코인 데이터인 transaction(거래내역)을 모으고 이전 블록의 해시를 구하고 나의 데이터 + 이전 블록의 해시를 합쳐서 다시 해시하여 블록의 해시를 만들면 블록체인에 블록을 추가할 수 있다. 그리고 다음 블록을 추가하고 싶다면 방금 합쳐서 만든 블록의 해시를 가지고 새로 추가하고자하는 데이터와 같이 결합해야한다.

이 방법으로 체인이 연결되고 input이 조금이라도 변경되면 output이 완전히 달라지게 되므로 누구도 블록체인을 변경할 수 없다.


### proof of work(feat. mining)
비트코인이나 이더리움처럼 사람들이 돈을 보내고 누가 얼마나 보냈고 잔금이 얼마인지의 기록들은 아무나 블록을 생성할 수 있어서는 안되며 어떤 데이터가 블록체인에 추가되는지도 조심해야하는데, 어떤 데이터가 블록체인에 추가될 수 있는가 하면 거짓이 아닌 진실을 담은 데이터이며 이것을 위해 작업증명(proof of work)이 필요하다.

작업증명을 통해서 비트고인, 이더리움 등 다양한 크립토들이 사기꾼, 악용사례 등으로 부터 블록체인을 보호한다. 

작업증명을 이해하려면 '채굴자'라는 컨셉을 이해해야하는데, 채굴자는 데이터를 블록 안에 넣어서 블록체인에 보내는 역할을 함으로써 블록체인에 들어오는 데이터를 확인한다. 
예를 들어 비트코인 블록체인에서 코인은 친구에게 보내면 이 거래내역은 확인되지 않는데 만약 채굴자가 해당 거래내역을 보고, 확인하여 친구에게 돈을 보낸 모든 내역을 체크하고, 해당 내용의 사실 체크가 끝나면 그 데이터를 블록 안에 넣는다. 이러한 체크를 여러개해서 블록이 꽉 차면 블록을 닫고 블록체인에 올리며 채굴자의 이러한 역할 덕분에 블록체인에 올라가야하는 데이터를 모두 체크할 수 있다. 
이 방식은 탈중앙화 방법으로 이루어지고 있어 누구나 원한다면 채굴자가 될 수 있고 누구나 데이터를 검증할 수 있다. 채굴자든은 돈을 벌기 위해서 이 작업을 하는데, 트랜잭션을 컨펌하게 되면 돈(transfer fee)을 받는다. 덕분에 검증 작업이 활발하게 이루어져서 사기꾼으로부터 네트워크를 보호할 수 있다.

블록체인에 블록을 추가하는 일은 굉장히 어려운데, 작업 증명은 전체 네트워크가 다 아는 질문을 채굴자에게 하는데 채굴자는 그 답을 찾으면 그때서야 블록을 올릴 수 있다.
이렇게 채굴자는 2번 보상을 받게 되는데, 한번은 거래내역을 컨펌하면서이고, 다른한번은 질문의 답을 찾아서 블록을 체인에 올리면서 이며 이때 비트코인이 생성된다. 즉, 사람들이 블록을 블록체인에 올리는 순간 비트코인이 생성된다. 
채굴자가 블록체인에 블록을 올릴때마다 coinbase transaction이라는게 생기는데 이것은 비트코인이 생성되는 순간이다. 비트코인은 원래부터 생성되어있는게 아니라 블록을 체인에 올릴때마다 새롭게 생성된다.

처음에는 블록을 올릴떄마다 50개의 코인이 생성되었는데, 비트코인은 무한정이 아니라 생산량이 2100만개로 한정되어있기 때문에 4년마다 반감기가 와서 생산량이 반으로 줄어든다.

작업 증명이 채굴자에게 던지는 질문은 데이터를 넣었을 때 나오는 output hash(nonce + previous block hash + block data)의 결과가 특정 갯수의 0(난이도)으로 시작려면 어떤 nonce를 가져아하는지와 같은 질문을 던진다. (0은 얼마나 블록을 찾기 어려운지의 난이도를 뜻하며 nonce 는 한번만 쓰인 숫자로 채굴자는 블록에 들어갈 데이터를 바꿀 수 없고 오직 검증만할 수 있으며 nonce만이 채굴자가 바꿀 수 있는 유일한 값이다.) nonce 값을 계속 바꾸어 hash 값을 맞출 수 있어 그 질문은 복잡한 답변을 가지고 있지만 그 답은 검증하기가 쉽다.

비트코인은 매 10분마다 블록을 새롭게 생성하며 너무 빨리 생성되면 난이도를 올리기도 한다.(0의 갯수는 난이도에 따른 결과일 뿐이고, 질문의 실제 난이도는 bits라는 걸 통해서 계산한다.)

그래픽 카드는 게임의 3D 환경이나 물리를 계산하기 위해 만들어졌기 떄문에 아주 빠르게 논스를 여러개 시도해몰 수 있어서 채굴자들은 그래픽 카드를 동원해서 논스를 찾기 때문에 그래픽 카드의 수요와 가격이 최근 급증하고 있다.(1초에 6천만 논스를 계산)


### Smart Contract
비트코인은 코인을 주고받는 것 외에 사람들과 교류할 수 없지만 smart contract를 이용하면 다른 사람들과 교류할 수 있고 코드로 소통할 수 있다.
개발자가 코딩을 해서 전체 네트워크가 검증하고 실행하는 공유 네트워크에 올릴 수 있다. 코딩을 해서 아마존 서버같은데에 올렸는데 혹시라도 서버가 터지게 되면 내 앱도 동작하지 않게 되는데, 코드를 탈중앙화된 공유 네트워크에 올리게 되면 그곳에 영원히 있어 사람들은 그 코드를 볼 수 있지만 변경할 수는 없다.
코드를 적어 주인이 없는 백엔드 즉, 전세계 사람들이 쓰는 공유 네트워크에 올리면 블록체인의 안정성을 구축한채 나의 코드를 검증하고 실행하게 된다.

스마트 컨트랙트를 이용해 많은 것들이 가능하기도 하지만 단점이 있는데 그중 하나는 원하는 소스를 다 활용할 수 없다. 스마트 컨트랙트는 결국 해당 블록체인 네트워크 위에서만 실행 가능한데, 예를 들어 다음날 비가 온다고 예상하여 비를 감지하는 센서와 스마트 컨트랙트를 연결하고 비가 오는 것에 베팅 한다고 하면 스마트 컨트랙트는 해당 비 감지 센서를 빋어야 하는데 이렇게 되면 이 거래는 trustless가 아닌 trustful, 신뢰 기반의 거래가 된다. 즉, 네트워크 외부의 무언가에 의존 혹은 신뢰해야하는 경우가 되며 누군가는 이를 조작할 수 있게 되며 이 경우 신뢰 기반이 아니니 전체가 무너지게 된다. 이것은 스마트 컨트랙트의 가장 큰 단점으로 신뢰 기반이 아닌 특수한 네트워크, 환경을 요구하며 누군가가 조작할 수 있는 인풋은 허용하지 않는다. 이것을 보완하기 위해서 oracle이 있는데, 이는 스마트 컨트랙에게 인풋을 제공하는데 신뢰기반의 데이터를 특수한 네트워크에 가져온다.

스마트 컨트랙트는 코드를 가져다가 모두가 공유, 검증, 실행하지만 수정은 불가능한 백엔드에 올리기 때문에 중개인이 필요 없고 규칙을 빠짐 없이 실행할 컨트랙트를 만들고 정부나 단체에 조종당할 염려 없이 네트워크에 의해 실행된다.

*스마트 컨트랙트를 지원하는 블록체인으로는 ethereum, kusama, polkadot, cardano, cosmos.. 등이 있다.

### NFT(Non Fungible Token)
Fungibility는 대체 가능하다라는 의미인데 1:1로 내가 1달러를 갖고있고 상대방이 1달러를 갖고 있다면 교화하여 대체할 수 있는 것을 의미한다.
Non fungibility는 땅, 한정판 신발, 전세 계약 같이 대체 불가능한 것을 의미하고, 토큰이란 이더리움 같은 블록체인은 자신만의 토큰을 발행할 수 있는데(이더리움은 이더라는 토큰은 갖고 있고 이더리움 기본으로 만들어진 코인들도 있다. 즉, 블록체인의 안정성을 기반으로 토큰을 발행해서 활용할 수 있다.)

토큰은 발행하는 방법으로는 스마트 컨트랙트를 만드는게 있는데 이더나 달러를 받으면 발행한 코인은 보내주는 방식으로 발행하여 사용할 수 있는데, NFT란 딱 한개만 발행하는 컨트랙트를 만들고 그 토큰 안에 이미지, 영상, 노래를 넣는 방식으로 탄생하게 된다. 특정 그림의 NFT를 구매한다는 것은 실제로 그 그림은 구매한다기 보다는 딱 1번만 실행되는 토큰을 구매하는 것이고 그 유일한 토큰 안에 이미지가 있다고 볼 수 있다.(파일이 저장되어 있는 토큰을 구매하는 셈) NFT는 창작자가 만든 원본임을 증명해준다.


ex. decentraland(이더리움 블록체인 기반의 vr 게임), axie infinity
nft로 인해 추가로 개발될만한 것들: nft frame, tockenized nft ticket reader

### wallet
비트코인을 보낸다는 것은 실제로 코인을 네트워크 상에서 전송하는 것이 아니며 항상 네트워크에 존재하며 떠나지 않는다.
집을 샀다고 해서 집의 주소가 바뀌는 것이 아니라 집 문서만 바뀌는 것처럼 암호화폐도 마찬가지이다. 비트코인을 소유한다는 의미는 실제고 주고 받는 것이 아니라 이 코인이 누구의 소유라는 기록을 남기는 것이다.
지갑은 엄청나게 긴 텍스트로 비트코인을 주고 받을 때 필요한데, 이 지갑은 asymmetric encryption(비대칭적 암호화)라는 것을 이용해서 생성된다.
symmetric encryption(대칭 암호)란 중요한 문서를 상대방에게 보낸다고 했을 때 문서를 안전한 박스에 넣어서 열쇠로 잠궈서 상대방에게 보내면 상대방은 그 열쇠가 필요하게 되는데 그 열쇠를 받아서 박스를 열어서 문서를 읽고 추가로 문서를 넣으렴녀 마찬가지로 문서를 박스에 넣고 다시 잠궈서 상대방에게 보내주는 방식을 의미한다.

이러한 방식은 한개의 열쇠를 주고받기 때문에 안전하지 않은데, 비대칭적 암호화는 열쇠가 한사람당 열쇠가 두개로 두명이 A와 B가 거래를 하게되면 열쇠는 총 4개가 되는데, 하나는 공개키(public key), 다른 하나는 비공개키(private key)이다. 공개키를 자물쇠이고 비공개키를 그 자물쇠를 여는 열쇠라고 생각했을 때 문서를 전달하기 위해서 A는 B의 공개키를 요구하게 된다. 문서를 A의 공개키와 함께 박스에 넣고 B의 공개키로 잠궈서 B에게 보내게 되면 B는 자신의 비공개키로 박스를 열 수 있고, B가 다시 A에게 문서를 보낼 때는 자신의 공개키와 문서를 박스에 넣고 A의 공개키로 박스를 잠궈서 A에게 보내게 된다.

이 공개키/비공개키 방식이 암호화폐에서 지갑이 동작하는 방식이다. public key로는 아무것도 할 수 없기 때문에 공개해도 무관하지만 private key는 항상 비밀로 남겨져있어야 한다.
지갑을 생성한다는 말은 비공개 키를 만든다는 것이며, 그 비공개키로 공개키를 만들고 아주 긴 주소인 공개키는 코인을 보낸다고 할 때 공유해야할 주소를 의미하고, 비트코인을 전송하거나 움직이고 싶을 떄 항상 그 비공개키가 필요하다.

비트코인을 전송할 때 우리가 하는 것은 해당 공개키를 열 수 있는 비공개 키를 갖고 있다는 것을 증명하는 것이다. 이를 네트워크에 증명하게 되면 비트코인을 움직일 수 있게 된다.




***
[Ref]



```toc

```
